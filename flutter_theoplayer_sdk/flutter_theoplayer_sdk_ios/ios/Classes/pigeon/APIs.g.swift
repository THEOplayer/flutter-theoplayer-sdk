// Autogenerated from Pigeon (v12.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum ReadyState: Int {
  case haveNothing = 0
  case haveMetadata = 1
  case haveCurrentData = 2
  case haveFutureData = 3
  case haveEnoughData = 4
}

enum TextTrackMode: Int {
  case disabled = 0
  case hidden = 1
  case showing = 2
}

enum TextTrackType: Int {
  case none = 0
  case srt = 1
  case ttml = 2
  case webvtt = 3
  case emsg = 4
  case eventstream = 5
  case id3 = 6
  case cea608 = 7
  case daterange = 8
}

enum TextTrackReadyState: Int {
  case none = 0
  case loading = 1
  case loaded = 2
  case error = 3
}

enum IntegrationKind: Int {
  case theoads = 0
  case googleIma = 1
  case googleDai = 2
  case mediatailor = 3
  case custom = 4
}

enum PreloadType: Int {
  case none = 0
  case auto = 1
  case metadata = 2
}

enum SourceIntegrationId: Int {
  case theolive = 0
}

/// Generated class from Pigeon that represents data sent in messages.
struct TimeRange {
  var start: Double
  var end: Double

  static func fromList(_ list: [Any?]) -> TimeRange? {
    let start = list[0] as! Double
    let end = list[1] as! Double

    return TimeRange(
      start: start,
      end: end
    )
  }
  func toList() -> [Any?] {
    return [
      start,
      end,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct Ad {
  var id: String
  var companions: [CompanionAd?]
  var type: String? = nil
  var adBreak: AdBreak? = nil
  var skipOffset: Int64
  var integration: IntegrationKind
  var customIntegration: String? = nil
  var customData: Any? = nil

  static func fromList(_ list: [Any?]) -> Ad? {
    let id = list[0] as! String
    let companions = list[1] as! [CompanionAd?]
    let type: String? = nilOrValue(list[2])
    var adBreak: AdBreak? = nil
    if let adBreakList: [Any?] = nilOrValue(list[3]) {
      adBreak = AdBreak.fromList(adBreakList)
    }
    let skipOffset = list[4] is Int64 ? list[4] as! Int64 : Int64(list[4] as! Int32)
    let integration = IntegrationKind(rawValue: list[5] as! Int)!
    let customIntegration: String? = nilOrValue(list[6])
    let customData: Any? = list[7]

    return Ad(
      id: id,
      companions: companions,
      type: type,
      adBreak: adBreak,
      skipOffset: skipOffset,
      integration: integration,
      customIntegration: customIntegration,
      customData: customData
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      companions,
      type,
      adBreak?.toList(),
      skipOffset,
      integration.rawValue,
      customIntegration,
      customData,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct CompanionAd {
  var adSlotId: String
  var altText: String
  var clickThrough: String
  var height: Int64
  var width: Int64
  var resourceURI: String
  var type: String

  static func fromList(_ list: [Any?]) -> CompanionAd? {
    let adSlotId = list[0] as! String
    let altText = list[1] as! String
    let clickThrough = list[2] as! String
    let height = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let width = list[4] is Int64 ? list[4] as! Int64 : Int64(list[4] as! Int32)
    let resourceURI = list[5] as! String
    let type = list[6] as! String

    return CompanionAd(
      adSlotId: adSlotId,
      altText: altText,
      clickThrough: clickThrough,
      height: height,
      width: width,
      resourceURI: resourceURI,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      adSlotId,
      altText,
      clickThrough,
      height,
      width,
      resourceURI,
      type,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AdBreak {
  var ads: [Ad?]
  var maxDuration: Int64
  var maxRemainingDuration: Int64
  var timeOffset: Int64
  var integration: IntegrationKind
  var customIntegration: String? = nil
  var customData: Any? = nil

  static func fromList(_ list: [Any?]) -> AdBreak? {
    let ads = list[0] as! [Ad?]
    let maxDuration = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let maxRemainingDuration = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)
    let timeOffset = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let integration = IntegrationKind(rawValue: list[4] as! Int)!
    let customIntegration: String? = nilOrValue(list[5])
    let customData: Any? = list[6]

    return AdBreak(
      ads: ads,
      maxDuration: maxDuration,
      maxRemainingDuration: maxRemainingDuration,
      timeOffset: timeOffset,
      integration: integration,
      customIntegration: customIntegration,
      customData: customData
    )
  }
  func toList() -> [Any?] {
    return [
      ads,
      maxDuration,
      maxRemainingDuration,
      timeOffset,
      integration.rawValue,
      customIntegration,
      customData,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AdDescription {
  var adIntegration: String

  static func fromList(_ list: [Any?]) -> AdDescription? {
    let adIntegration = list[0] as! String

    return AdDescription(
      adIntegration: adIntegration
    )
  }
  func toList() -> [Any?] {
    return [
      adIntegration,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SourceDescription {
  var sources: [TypedSource?]

  static func fromList(_ list: [Any?]) -> SourceDescription? {
    let sources = list[0] as! [TypedSource?]

    return SourceDescription(
      sources: sources
    )
  }
  func toList() -> [Any?] {
    return [
      sources,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct TypedSource {
  var src: String
  var drm: DRMConfiguration? = nil
  var integration: SourceIntegrationId? = nil

  static func fromList(_ list: [Any?]) -> TypedSource? {
    let src = list[0] as! String
    var drm: DRMConfiguration? = nil
    if let drmList: [Any?] = nilOrValue(list[1]) {
      drm = DRMConfiguration.fromList(drmList)
    }
    var integration: SourceIntegrationId? = nil
    let integrationEnumVal: Int? = nilOrValue(list[2])
    if let integrationRawValue = integrationEnumVal {
      integration = SourceIntegrationId(rawValue: integrationRawValue)!
    }

    return TypedSource(
      src: src,
      drm: drm,
      integration: integration
    )
  }
  func toList() -> [Any?] {
    return [
      src,
      drm?.toList(),
      integration?.rawValue,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DRMConfiguration {
  var widevine: WidevineDRMConfiguration? = nil
  var fairplay: FairPlayDRMConfiguration? = nil
  var customIntegrationId: String? = nil
  var integrationParameters: [String?: String?]? = nil

  static func fromList(_ list: [Any?]) -> DRMConfiguration? {
    var widevine: WidevineDRMConfiguration? = nil
    if let widevineList: [Any?] = nilOrValue(list[0]) {
      widevine = WidevineDRMConfiguration.fromList(widevineList)
    }
    var fairplay: FairPlayDRMConfiguration? = nil
    if let fairplayList: [Any?] = nilOrValue(list[1]) {
      fairplay = FairPlayDRMConfiguration.fromList(fairplayList)
    }
    let customIntegrationId: String? = nilOrValue(list[2])
    let integrationParameters: [String?: String?]? = nilOrValue(list[3])

    return DRMConfiguration(
      widevine: widevine,
      fairplay: fairplay,
      customIntegrationId: customIntegrationId,
      integrationParameters: integrationParameters
    )
  }
  func toList() -> [Any?] {
    return [
      widevine?.toList(),
      fairplay?.toList(),
      customIntegrationId,
      integrationParameters,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct WidevineDRMConfiguration {
  var licenseAcquisitionURL: String
  var headers: [String?: String?]? = nil

  static func fromList(_ list: [Any?]) -> WidevineDRMConfiguration? {
    let licenseAcquisitionURL = list[0] as! String
    let headers: [String?: String?]? = nilOrValue(list[1])

    return WidevineDRMConfiguration(
      licenseAcquisitionURL: licenseAcquisitionURL,
      headers: headers
    )
  }
  func toList() -> [Any?] {
    return [
      licenseAcquisitionURL,
      headers,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct FairPlayDRMConfiguration {
  var licenseAcquisitionURL: String
  var certificateURL: String
  var headers: [String?: String?]? = nil

  static func fromList(_ list: [Any?]) -> FairPlayDRMConfiguration? {
    let licenseAcquisitionURL = list[0] as! String
    let certificateURL = list[1] as! String
    let headers: [String?: String?]? = nilOrValue(list[2])

    return FairPlayDRMConfiguration(
      licenseAcquisitionURL: licenseAcquisitionURL,
      certificateURL: certificateURL,
      headers: headers
    )
  }
  func toList() -> [Any?] {
    return [
      licenseAcquisitionURL,
      certificateURL,
      headers,
    ]
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeTextTracksAPI {
  func setMode(textTrackUid: Int64, mode: TextTrackMode) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeTextTracksAPISetup {
  /// The codec used by THEOplayerNativeTextTracksAPI.
  /// Sets up an instance of `THEOplayerNativeTextTracksAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeTextTracksAPI?) {
    let setModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeTextTracksAPI.setMode", binaryMessenger: binaryMessenger)
    if let api = api {
      setModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let textTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let modeArg = TextTrackMode(rawValue: args[1] as! Int)!
        do {
          try api.setMode(textTrackUid: textTrackUidArg, mode: modeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setModeChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterTextTracksAPIProtocol {
  func onAddTextTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, inBandMetadataTrackDispatchType inBandMetadataTrackDispatchTypeArg: String?, readyState readyStateArg: TextTrackReadyState, type typeArg: TextTrackType, source sourceArg: String?, isForced isForcedArg: Bool, mode modeArg: TextTrackMode, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRemoveTextTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackAddCue(textTrackUid textTrackUidArg: Int64, id idArg: String, uid uidArg: Int64, startTime startTimeArg: Double, endTime endTimeArg: Double, content contentArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackRemoveCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackEnterCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackExitCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackCueChange(textTrackUid textTrackUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackChange(textTrackUid textTrackUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCueEnter(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCueExit(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCueUpdate(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, endTime endTimeArg: Double, content contentArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterTextTracksAPI: THEOplayerFlutterTextTracksAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  func onAddTextTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, inBandMetadataTrackDispatchType inBandMetadataTrackDispatchTypeArg: String?, readyState readyStateArg: TextTrackReadyState, type typeArg: TextTrackType, source sourceArg: String?, isForced isForcedArg: Bool, mode modeArg: TextTrackMode, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onAddTextTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([idArg, uidArg, labelArg, languageArg, kindArg, inBandMetadataTrackDispatchTypeArg, readyStateArg.rawValue, typeArg.rawValue, sourceArg, isForcedArg, modeArg.rawValue] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRemoveTextTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onRemoveTextTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackListChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackAddCue(textTrackUid textTrackUidArg: Int64, id idArg: String, uid uidArg: Int64, startTime startTimeArg: Double, endTime endTimeArg: Double, content contentArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackAddCue", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, idArg, uidArg, startTimeArg, endTimeArg, contentArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackRemoveCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackRemoveCue", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackEnterCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackEnterCue", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackExitCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackExitCue", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackCueChange(textTrackUid textTrackUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackCueChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackChange(textTrackUid textTrackUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCueEnter(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onCueEnter", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCueExit(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onCueExit", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCueUpdate(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, endTime endTimeArg: Double, content contentArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onCueUpdate", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg, endTimeArg, contentArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
private class THEOplayerNativeAPICodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return DRMConfiguration.fromList(self.readValue() as! [Any?])
      case 129:
        return FairPlayDRMConfiguration.fromList(self.readValue() as! [Any?])
      case 130:
        return SourceDescription.fromList(self.readValue() as! [Any?])
      case 131:
        return TimeRange.fromList(self.readValue() as! [Any?])
      case 132:
        return TypedSource.fromList(self.readValue() as! [Any?])
      case 133:
        return WidevineDRMConfiguration.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class THEOplayerNativeAPICodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? DRMConfiguration {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? FairPlayDRMConfiguration {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? SourceDescription {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? TimeRange {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? TypedSource {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? WidevineDRMConfiguration {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class THEOplayerNativeAPICodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return THEOplayerNativeAPICodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return THEOplayerNativeAPICodecWriter(data: data)
  }
}

class THEOplayerNativeAPICodec: FlutterStandardMessageCodec {
  static let shared = THEOplayerNativeAPICodec(readerWriter: THEOplayerNativeAPICodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeAPI {
  func setSource(source: SourceDescription?) throws
  func getSource() throws -> SourceDescription?
  func setAutoplay(autoplay: Bool) throws
  func isAutoplay() throws -> Bool
  func play() throws
  func pause() throws
  func isPaused() throws -> Bool
  func setCurrentTime(currentTime: Double) throws
  func getCurrentTime() throws -> Double
  func setCurrentProgramDateTime(currentProgramDateTime: Int64) throws
  func getCurrentProgramDateTime() throws -> Int64?
  func getDuration() throws -> Double
  func setPlaybackRate(playbackRate: Double) throws
  func getPlaybackRate() throws -> Double
  func setVolume(volume: Double) throws
  func getVolume() throws -> Double
  func setMuted(muted: Bool) throws
  func isMuted() throws -> Bool
  func setPreload(preload: PreloadType) throws
  func getPreload() throws -> PreloadType
  func getReadyState() throws -> ReadyState
  func isSeeking() throws -> Bool
  func isEnded() throws -> Bool
  func getVideoWidth() throws -> Int64
  func getVideoHeight() throws -> Int64
  func getBuffered() throws -> [TimeRange]
  func getSeekable() throws -> [TimeRange]
  func getPlayed() throws -> [TimeRange]
  func setAllowBackgroundPlayback(allowBackgroundPlayback: Bool) throws
  func allowBackgroundPlayback() throws -> Bool
  func setAllowAutomaticPictureInPicture(allowAutomaticPictureInPicture: Bool) throws
  func allowAutomaticPictureInPicture() throws -> Bool
  func getError() throws -> String?
  func stop() throws
  func dispose() throws
  func onLifecycleResume() throws
  func onLifecyclePause() throws
  func configureSurface(surfaceId: Int64, width: Int64, height: Int64) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeAPISetup {
  /// The codec used by THEOplayerNativeAPI.
  static var codec: FlutterStandardMessageCodec { THEOplayerNativeAPICodec.shared }
  /// Sets up an instance of `THEOplayerNativeAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeAPI?) {
    let setSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setSource", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSourceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceArg: SourceDescription? = nilOrValue(args[0])
        do {
          try api.setSource(source: sourceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setSourceChannel.setMessageHandler(nil)
    }
    let getSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getSource", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSourceChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSource()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSourceChannel.setMessageHandler(nil)
    }
    let setAutoplayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setAutoplay", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAutoplayChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let autoplayArg = args[0] as! Bool
        do {
          try api.setAutoplay(autoplay: autoplayArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAutoplayChannel.setMessageHandler(nil)
    }
    let isAutoplayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isAutoplay", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isAutoplayChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isAutoplay()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isAutoplayChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { _, reply in
        do {
          try api.play()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { _, reply in
        do {
          try api.pause()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let isPausedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isPaused", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPausedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isPaused()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPausedChannel.setMessageHandler(nil)
    }
    let setCurrentTimeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setCurrentTime", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCurrentTimeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let currentTimeArg = args[0] as! Double
        do {
          try api.setCurrentTime(currentTime: currentTimeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCurrentTimeChannel.setMessageHandler(nil)
    }
    let getCurrentTimeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getCurrentTime", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentTimeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCurrentTime()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentTimeChannel.setMessageHandler(nil)
    }
    let setCurrentProgramDateTimeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setCurrentProgramDateTime", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCurrentProgramDateTimeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let currentProgramDateTimeArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.setCurrentProgramDateTime(currentProgramDateTime: currentProgramDateTimeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCurrentProgramDateTimeChannel.setMessageHandler(nil)
    }
    let getCurrentProgramDateTimeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getCurrentProgramDateTime", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentProgramDateTimeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCurrentProgramDateTime()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentProgramDateTimeChannel.setMessageHandler(nil)
    }
    let getDurationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getDuration", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDurationChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getDuration()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDurationChannel.setMessageHandler(nil)
    }
    let setPlaybackRateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setPlaybackRate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPlaybackRateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playbackRateArg = args[0] as! Double
        do {
          try api.setPlaybackRate(playbackRate: playbackRateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPlaybackRateChannel.setMessageHandler(nil)
    }
    let getPlaybackRateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getPlaybackRate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlaybackRateChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPlaybackRate()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPlaybackRateChannel.setMessageHandler(nil)
    }
    let setVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setVolume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let volumeArg = args[0] as! Double
        do {
          try api.setVolume(volume: volumeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVolumeChannel.setMessageHandler(nil)
    }
    let getVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getVolume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVolumeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getVolume()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVolumeChannel.setMessageHandler(nil)
    }
    let setMutedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setMuted", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMutedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mutedArg = args[0] as! Bool
        do {
          try api.setMuted(muted: mutedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMutedChannel.setMessageHandler(nil)
    }
    let isMutedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isMuted", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isMutedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isMuted()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isMutedChannel.setMessageHandler(nil)
    }
    let setPreloadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setPreload", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPreloadChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let preloadArg = PreloadType(rawValue: args[0] as! Int)!
        do {
          try api.setPreload(preload: preloadArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPreloadChannel.setMessageHandler(nil)
    }
    let getPreloadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getPreload", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPreloadChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPreload()
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPreloadChannel.setMessageHandler(nil)
    }
    let getReadyStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getReadyState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getReadyStateChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getReadyState()
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getReadyStateChannel.setMessageHandler(nil)
    }
    let isSeekingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isSeeking", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isSeekingChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isSeeking()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isSeekingChannel.setMessageHandler(nil)
    }
    let isEndedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isEnded", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isEndedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isEnded()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isEndedChannel.setMessageHandler(nil)
    }
    let getVideoWidthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getVideoWidth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoWidthChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getVideoWidth()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoWidthChannel.setMessageHandler(nil)
    }
    let getVideoHeightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getVideoHeight", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoHeightChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getVideoHeight()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoHeightChannel.setMessageHandler(nil)
    }
    let getBufferedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getBuffered", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getBufferedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getBuffered()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getBufferedChannel.setMessageHandler(nil)
    }
    let getSeekableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getSeekable", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSeekableChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSeekable()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSeekableChannel.setMessageHandler(nil)
    }
    let getPlayedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getPlayed", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlayedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPlayed()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPlayedChannel.setMessageHandler(nil)
    }
    let setAllowBackgroundPlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setAllowBackgroundPlayback", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAllowBackgroundPlaybackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let allowBackgroundPlaybackArg = args[0] as! Bool
        do {
          try api.setAllowBackgroundPlayback(allowBackgroundPlayback: allowBackgroundPlaybackArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAllowBackgroundPlaybackChannel.setMessageHandler(nil)
    }
    let allowBackgroundPlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.allowBackgroundPlayback", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      allowBackgroundPlaybackChannel.setMessageHandler { _, reply in
        do {
          let result = try api.allowBackgroundPlayback()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      allowBackgroundPlaybackChannel.setMessageHandler(nil)
    }
    let setAllowAutomaticPictureInPictureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setAllowAutomaticPictureInPicture", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAllowAutomaticPictureInPictureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let allowAutomaticPictureInPictureArg = args[0] as! Bool
        do {
          try api.setAllowAutomaticPictureInPicture(allowAutomaticPictureInPicture: allowAutomaticPictureInPictureArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAllowAutomaticPictureInPictureChannel.setMessageHandler(nil)
    }
    let allowAutomaticPictureInPictureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.allowAutomaticPictureInPicture", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      allowAutomaticPictureInPictureChannel.setMessageHandler { _, reply in
        do {
          let result = try api.allowAutomaticPictureInPicture()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      allowAutomaticPictureInPictureChannel.setMessageHandler(nil)
    }
    let getErrorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getError", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getErrorChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getError()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getErrorChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.stop", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { _, reply in
        do {
          try api.stop()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.dispose", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { _, reply in
        do {
          try api.dispose()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    let onLifecycleResumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.onLifecycleResume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      onLifecycleResumeChannel.setMessageHandler { _, reply in
        do {
          try api.onLifecycleResume()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      onLifecycleResumeChannel.setMessageHandler(nil)
    }
    let onLifecyclePauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.onLifecyclePause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      onLifecyclePauseChannel.setMessageHandler { _, reply in
        do {
          try api.onLifecyclePause()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      onLifecyclePauseChannel.setMessageHandler(nil)
    }
    let configureSurfaceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.configureSurface", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      configureSurfaceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let surfaceIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let widthArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        let heightArg = args[2] is Int64 ? args[2] as! Int64 : Int64(args[2] as! Int32)
        do {
          try api.configureSurface(surfaceId: surfaceIdArg, width: widthArg, height: heightArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      configureSurfaceChannel.setMessageHandler(nil)
    }
  }
}
private class THEOplayerFlutterAPICodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return DRMConfiguration.fromList(self.readValue() as! [Any?])
      case 129:
        return FairPlayDRMConfiguration.fromList(self.readValue() as! [Any?])
      case 130:
        return SourceDescription.fromList(self.readValue() as! [Any?])
      case 131:
        return TypedSource.fromList(self.readValue() as! [Any?])
      case 132:
        return WidevineDRMConfiguration.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class THEOplayerFlutterAPICodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? DRMConfiguration {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? FairPlayDRMConfiguration {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? SourceDescription {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? TypedSource {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? WidevineDRMConfiguration {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class THEOplayerFlutterAPICodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return THEOplayerFlutterAPICodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return THEOplayerFlutterAPICodecWriter(data: data)
  }
}

class THEOplayerFlutterAPICodec: FlutterStandardMessageCodec {
  static let shared = THEOplayerFlutterAPICodec(readerWriter: THEOplayerFlutterAPICodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterAPIProtocol {
  func onSourceChange(source sourceArg: SourceDescription?, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onPlay(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onPlaying(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onPause(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onWaiting(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onDurationChange(duration durationArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onProgress(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTimeUpdate(currentTime currentTimeArg: Double, currentProgramDateTime currentProgramDateTimeArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRateChange(currentTime currentTimeArg: Double, playbackRate playbackRateArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onSeeking(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onSeeked(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onVolumeChange(currentTime currentTimeArg: Double, volume volumeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onResize(currentTime currentTimeArg: Double, width widthArg: Int64, height heightArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onEnded(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onError(error errorArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onDestroy(completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onReadyStateChange(currentTime currentTimeArg: Double, readyState readyStateArg: ReadyState, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onLoadStart(completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onLoadedMetadata(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onLoadedData(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCanPlay(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCanPlayThrough(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterAPI: THEOplayerFlutterAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return THEOplayerFlutterAPICodec.shared
  }
  func onSourceChange(source sourceArg: SourceDescription?, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onSourceChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([sourceArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onPlay(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onPlay", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onPlaying(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onPlaying", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onPause(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onPause", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onWaiting(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onWaiting", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onDurationChange(duration durationArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onDurationChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([durationArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onProgress(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onProgress", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTimeUpdate(currentTime currentTimeArg: Double, currentProgramDateTime currentProgramDateTimeArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onTimeUpdate", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, currentProgramDateTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRateChange(currentTime currentTimeArg: Double, playbackRate playbackRateArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onRateChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, playbackRateArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onSeeking(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onSeeking", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onSeeked(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onSeeked", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onVolumeChange(currentTime currentTimeArg: Double, volume volumeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onVolumeChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, volumeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onResize(currentTime currentTimeArg: Double, width widthArg: Int64, height heightArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onResize", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, widthArg, heightArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onEnded(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onEnded", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onError(error errorArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onError", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([errorArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onDestroy(completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onDestroy", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { _ in
      completion(.success(Void()))
    }
  }
  func onReadyStateChange(currentTime currentTimeArg: Double, readyState readyStateArg: ReadyState, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onReadyStateChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, readyStateArg.rawValue] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onLoadStart(completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onLoadStart", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { _ in
      completion(.success(Void()))
    }
  }
  func onLoadedMetadata(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onLoadedMetadata", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onLoadedData(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onLoadedData", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCanPlay(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onCanPlay", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCanPlayThrough(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onCanPlayThrough", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
private class THEOplayerFlutterAdsAPICodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return Ad.fromList(self.readValue() as! [Any?])
      case 129:
        return AdBreak.fromList(self.readValue() as! [Any?])
      case 130:
        return CompanionAd.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class THEOplayerFlutterAdsAPICodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Ad {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? AdBreak {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? CompanionAd {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class THEOplayerFlutterAdsAPICodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return THEOplayerFlutterAdsAPICodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return THEOplayerFlutterAdsAPICodecWriter(data: data)
  }
}

class THEOplayerFlutterAdsAPICodec: FlutterStandardMessageCodec {
  static let shared = THEOplayerFlutterAdsAPICodec(readerWriter: THEOplayerFlutterAdsAPICodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterAdsAPIProtocol {
  func onAdBegin(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdBreakBegin(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdBreakChange(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdBreakEnd(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdClicked(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAddAdBreak(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAddAd(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdEnd(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdError(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdFirstQuartile(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdImpression(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdLoaded(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdMidpoint(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdSkip(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdTapped(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAdThirdQuartile(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRemoveAdBreak(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterAdsAPI: THEOplayerFlutterAdsAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return THEOplayerFlutterAdsAPICodec.shared
  }
  func onAdBegin(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdBegin", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdBreakBegin(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdBreakBegin", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adbreakArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdBreakChange(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdBreakChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adbreakArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdBreakEnd(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdBreakEnd", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adbreakArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdClicked(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdClicked", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAddAdBreak(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAddAdBreak", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adbreakArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAddAd(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAddAd", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdEnd(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdEnd", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdError(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdError", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdFirstQuartile(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdFirstQuartile", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdImpression(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdImpression", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdLoaded(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdLoaded", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdMidpoint(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdMidpoint", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdSkip(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdSkip", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdTapped(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdTapped", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAdThirdQuartile(ad adArg: Ad, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onAdThirdQuartile", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRemoveAdBreak(adbreak adbreakArg: AdBreak, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAdsAPI.onRemoveAdBreak", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([adbreakArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
private class THEOplayerNativeAdsAPICodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return Ad.fromList(self.readValue() as! [Any?])
      case 129:
        return AdBreak.fromList(self.readValue() as! [Any?])
      case 130:
        return AdDescription.fromList(self.readValue() as! [Any?])
      case 131:
        return CompanionAd.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class THEOplayerNativeAdsAPICodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Ad {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? AdBreak {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? AdDescription {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? CompanionAd {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class THEOplayerNativeAdsAPICodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return THEOplayerNativeAdsAPICodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return THEOplayerNativeAdsAPICodecWriter(data: data)
  }
}

class THEOplayerNativeAdsAPICodec: FlutterStandardMessageCodec {
  static let shared = THEOplayerNativeAdsAPICodec(readerWriter: THEOplayerNativeAdsAPICodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeAdsAPI {
  func isPlaying() throws -> Bool
  func getCurrentAds() throws -> [Ad]
  func getCurrentAdBreak() throws -> AdBreak
  func getScheduledAds() throws -> [Ad]
  func schedule(adDescription: AdDescription) throws
  func skip() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeAdsAPISetup {
  /// The codec used by THEOplayerNativeAdsAPI.
  static var codec: FlutterStandardMessageCodec { THEOplayerNativeAdsAPICodec.shared }
  /// Sets up an instance of `THEOplayerNativeAdsAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeAdsAPI?) {
    let isPlayingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAdsAPI.isPlaying", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPlayingChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isPlaying()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPlayingChannel.setMessageHandler(nil)
    }
    let getCurrentAdsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAdsAPI.getCurrentAds", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentAdsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCurrentAds()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentAdsChannel.setMessageHandler(nil)
    }
    let getCurrentAdBreakChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAdsAPI.getCurrentAdBreak", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentAdBreakChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCurrentAdBreak()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentAdBreakChannel.setMessageHandler(nil)
    }
    let getScheduledAdsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAdsAPI.getScheduledAds", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getScheduledAdsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getScheduledAds()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getScheduledAdsChannel.setMessageHandler(nil)
    }
    let scheduleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAdsAPI.schedule", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      scheduleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let adDescriptionArg = args[0] as! AdDescription
        do {
          try api.schedule(adDescription: adDescriptionArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      scheduleChannel.setMessageHandler(nil)
    }
    let skipChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAdsAPI.skip", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      skipChannel.setMessageHandler { _, reply in
        do {
          try api.skip()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      skipChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeVideoTracksAPI {
  func setTargetQuality(videoTrackUid: Int64, qualityUid: Int64?) throws
  func setTargetQualities(videoTrackUid: Int64, qualitiesUid: [Int64]?) throws
  func setEnabled(videoTrackUid: Int64, enabled: Bool) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeVideoTracksAPISetup {
  /// The codec used by THEOplayerNativeVideoTracksAPI.
  /// Sets up an instance of `THEOplayerNativeVideoTracksAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeVideoTracksAPI?) {
    let setTargetQualityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeVideoTracksAPI.setTargetQuality", binaryMessenger: binaryMessenger)
    if let api = api {
      setTargetQualityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let videoTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let qualityUidArg: Int64? = isNullish(args[1]) ? nil : (args[1] is Int64? ? args[1] as! Int64? : Int64(args[1] as! Int32))
        do {
          try api.setTargetQuality(videoTrackUid: videoTrackUidArg, qualityUid: qualityUidArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTargetQualityChannel.setMessageHandler(nil)
    }
    let setTargetQualitiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeVideoTracksAPI.setTargetQualities", binaryMessenger: binaryMessenger)
    if let api = api {
      setTargetQualitiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let videoTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let qualitiesUidArg: [Int64]? = nilOrValue(args[1])
        do {
          try api.setTargetQualities(videoTrackUid: videoTrackUidArg, qualitiesUid: qualitiesUidArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTargetQualitiesChannel.setMessageHandler(nil)
    }
    let setEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeVideoTracksAPI.setEnabled", binaryMessenger: binaryMessenger)
    if let api = api {
      setEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let videoTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setEnabled(videoTrackUid: videoTrackUidArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setEnabledChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterVideoTracksAPIProtocol {
  func onAddVideoTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, isEnabled isEnabledArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onVideoTrackAddQuality(videoTrackUid videoTrackUidArg: Int64, qualityId qualityIdArg: String, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, width widthArg: Int64, height heightArg: Int64, frameRate frameRateArg: Double, firstFrame firstFrameArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRemoveVideoTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onVideoTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTargetQualityChange(videoTrackUid videoTrackUidArg: Int64, qualitiesUid qualitiesUidArg: [Int64], qualityUid qualityUidArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onActiveQualityChange(videoTrackUid videoTrackUidArg: Int64, qualityUid qualityUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onQualityUpdate(videoTrackUid videoTrackUidArg: Int64, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, width widthArg: Int64, height heightArg: Int64, frameRate frameRateArg: Double, firstFrame firstFrameArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterVideoTracksAPI: THEOplayerFlutterVideoTracksAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  func onAddVideoTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, isEnabled isEnabledArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onAddVideoTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([idArg, uidArg, labelArg, languageArg, kindArg, isEnabledArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onVideoTrackAddQuality(videoTrackUid videoTrackUidArg: Int64, qualityId qualityIdArg: String, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, width widthArg: Int64, height heightArg: Int64, frameRate frameRateArg: Double, firstFrame firstFrameArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onVideoTrackAddQuality", binaryMessenger: binaryMessenger)
    channel.sendMessage([videoTrackUidArg, qualityIdArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, widthArg, heightArg, frameRateArg, firstFrameArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRemoveVideoTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onRemoveVideoTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onVideoTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onVideoTrackListChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTargetQualityChange(videoTrackUid videoTrackUidArg: Int64, qualitiesUid qualitiesUidArg: [Int64], qualityUid qualityUidArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onTargetQualityChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([videoTrackUidArg, qualitiesUidArg, qualityUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onActiveQualityChange(videoTrackUid videoTrackUidArg: Int64, qualityUid qualityUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onActiveQualityChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([videoTrackUidArg, qualityUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onQualityUpdate(videoTrackUid videoTrackUidArg: Int64, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, width widthArg: Int64, height heightArg: Int64, frameRate frameRateArg: Double, firstFrame firstFrameArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onQualityUpdate", binaryMessenger: binaryMessenger)
    channel.sendMessage([videoTrackUidArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, widthArg, heightArg, frameRateArg, firstFrameArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeAudioTracksAPI {
  func setTargetQuality(audioTrackUid: Int64, qualityUid: Int64?) throws
  func setTargetQualities(audioTrackUid: Int64, qualitiesUid: [Int64]?) throws
  func setEnabled(audioTrackUid: Int64, enabled: Bool) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeAudioTracksAPISetup {
  /// The codec used by THEOplayerNativeAudioTracksAPI.
  /// Sets up an instance of `THEOplayerNativeAudioTracksAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeAudioTracksAPI?) {
    let setTargetQualityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAudioTracksAPI.setTargetQuality", binaryMessenger: binaryMessenger)
    if let api = api {
      setTargetQualityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let audioTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let qualityUidArg: Int64? = isNullish(args[1]) ? nil : (args[1] is Int64? ? args[1] as! Int64? : Int64(args[1] as! Int32))
        do {
          try api.setTargetQuality(audioTrackUid: audioTrackUidArg, qualityUid: qualityUidArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTargetQualityChannel.setMessageHandler(nil)
    }
    let setTargetQualitiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAudioTracksAPI.setTargetQualities", binaryMessenger: binaryMessenger)
    if let api = api {
      setTargetQualitiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let audioTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let qualitiesUidArg: [Int64]? = nilOrValue(args[1])
        do {
          try api.setTargetQualities(audioTrackUid: audioTrackUidArg, qualitiesUid: qualitiesUidArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTargetQualitiesChannel.setMessageHandler(nil)
    }
    let setEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAudioTracksAPI.setEnabled", binaryMessenger: binaryMessenger)
    if let api = api {
      setEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let audioTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setEnabled(audioTrackUid: audioTrackUidArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setEnabledChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterAudioTracksAPIProtocol {
  func onAddAudioTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, isEnabled isEnabledArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAudioTrackAddQuality(audioTrackUid audioTrackUidArg: Int64, qualityId qualityIdArg: String, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, audioSamplingRate audioSamplingRateArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRemoveAudioTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAudioTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTargetQualityChange(audioTrackUid audioTrackUidArg: Int64, qualitiesUid qualitiesUidArg: [Int64], qualityUid qualityUidArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onActiveQualityChange(audioTrackUid audioTrackUidArg: Int64, qualityUid qualityUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onQualityUpdate(audioTrackUid audioTrackUidArg: Int64, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, audioSamplingRate audioSamplingRateArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterAudioTracksAPI: THEOplayerFlutterAudioTracksAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  func onAddAudioTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, isEnabled isEnabledArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onAddAudioTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([idArg, uidArg, labelArg, languageArg, kindArg, isEnabledArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAudioTrackAddQuality(audioTrackUid audioTrackUidArg: Int64, qualityId qualityIdArg: String, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, audioSamplingRate audioSamplingRateArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onAudioTrackAddQuality", binaryMessenger: binaryMessenger)
    channel.sendMessage([audioTrackUidArg, qualityIdArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, audioSamplingRateArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRemoveAudioTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onRemoveAudioTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAudioTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onAudioTrackListChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTargetQualityChange(audioTrackUid audioTrackUidArg: Int64, qualitiesUid qualitiesUidArg: [Int64], qualityUid qualityUidArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onTargetQualityChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([audioTrackUidArg, qualitiesUidArg, qualityUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onActiveQualityChange(audioTrackUid audioTrackUidArg: Int64, qualityUid qualityUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onActiveQualityChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([audioTrackUidArg, qualityUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onQualityUpdate(audioTrackUid audioTrackUidArg: Int64, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, audioSamplingRate audioSamplingRateArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onQualityUpdate", binaryMessenger: binaryMessenger)
    channel.sendMessage([audioTrackUidArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, audioSamplingRateArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
