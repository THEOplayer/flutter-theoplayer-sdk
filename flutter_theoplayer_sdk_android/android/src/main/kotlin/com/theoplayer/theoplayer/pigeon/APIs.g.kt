// Autogenerated from Pigeon (v12.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.theoplayer.theoplayer.pigeon

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

enum class ReadyState(val raw: Int) {
  HAVE_NOTHING(0),
  HAVE_METADATA(1),
  HAVE_CURRENT_DATA(2),
  HAVE_FUTURE_DATA(3),
  HAVE_ENOUGH_DATA(4);

  companion object {
    fun ofRaw(raw: Int): ReadyState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class TextTrackMode(val raw: Int) {
  DISABLED(0),
  HIDDEN(1),
  SHOWING(2);

  companion object {
    fun ofRaw(raw: Int): TextTrackMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class TextTrackType(val raw: Int) {
  NONE(0),
  SRT(1),
  TTML(2),
  WEBVTT(3),
  EMSG(4),
  EVENTSTREAM(5),
  ID3(6),
  CEA608(7),
  DATERANGE(8);

  companion object {
    fun ofRaw(raw: Int): TextTrackType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class TextTrackReadyState(val raw: Int) {
  NONE(0),
  LOADING(1),
  LOADED(2),
  ERROR(3);

  companion object {
    fun ofRaw(raw: Int): TextTrackReadyState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PreloadType(val raw: Int) {
  NONE(0),
  AUTO(1),
  METADATA(2);

  companion object {
    fun ofRaw(raw: Int): PreloadType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TimeRange (
  val start: Double,
  val end: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): TimeRange {
      val start = list[0] as Double
      val end = list[1] as Double
      return TimeRange(start, end)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      start,
      end,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SourceDescription (
  val sources: List<TypedSource?>

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): SourceDescription {
      val sources = list[0] as List<TypedSource?>
      return SourceDescription(sources)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      sources,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TypedSource (
  val src: String,
  val drm: DRMConfiguration? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): TypedSource {
      val src = list[0] as String
      val drm: DRMConfiguration? = (list[1] as List<Any?>?)?.let {
        DRMConfiguration.fromList(it)
      }
      return TypedSource(src, drm)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      src,
      drm?.toList(),
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class DRMConfiguration (
  val widevine: WidevineDRMConfiguration? = null,
  val fairplay: FairPlayDRMConfiguration? = null,
  val customIntegrationId: String? = null,
  val integrationParameters: Map<String?, String?>? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): DRMConfiguration {
      val widevine: WidevineDRMConfiguration? = (list[0] as List<Any?>?)?.let {
        WidevineDRMConfiguration.fromList(it)
      }
      val fairplay: FairPlayDRMConfiguration? = (list[1] as List<Any?>?)?.let {
        FairPlayDRMConfiguration.fromList(it)
      }
      val customIntegrationId = list[2] as String?
      val integrationParameters = list[3] as Map<String?, String?>?
      return DRMConfiguration(widevine, fairplay, customIntegrationId, integrationParameters)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      widevine?.toList(),
      fairplay?.toList(),
      customIntegrationId,
      integrationParameters,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class WidevineDRMConfiguration (
  val licenseAcquisitionURL: String,
  val headers: Map<String?, String?>? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): WidevineDRMConfiguration {
      val licenseAcquisitionURL = list[0] as String
      val headers = list[1] as Map<String?, String?>?
      return WidevineDRMConfiguration(licenseAcquisitionURL, headers)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      licenseAcquisitionURL,
      headers,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class FairPlayDRMConfiguration (
  val licenseAcquisitionURL: String,
  val certificateURL: String,
  val headers: Map<String?, String?>? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): FairPlayDRMConfiguration {
      val licenseAcquisitionURL = list[0] as String
      val certificateURL = list[1] as String
      val headers = list[2] as Map<String?, String?>?
      return FairPlayDRMConfiguration(licenseAcquisitionURL, certificateURL, headers)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      licenseAcquisitionURL,
      certificateURL,
      headers,
    )
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface THEOplayerNativeTextTracksAPI {
  fun setMode(textTrackUid: Long, mode: TextTrackMode)

  companion object {
    /** The codec used by THEOplayerNativeTextTracksAPI. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `THEOplayerNativeTextTracksAPI` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: THEOplayerNativeTextTracksAPI?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeTextTracksAPI.setMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val textTrackUidArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val modeArg = TextTrackMode.ofRaw(args[1] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setMode(textTrackUidArg, modeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
@Suppress("UNCHECKED_CAST")
class THEOplayerFlutterTextTracksAPI(private val binaryMessenger: BinaryMessenger) {
  companion object {
    /** The codec used by THEOplayerFlutterTextTracksAPI. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
  }
  fun onAddTextTrack(idArg: String?, uidArg: Long, labelArg: String?, languageArg: String?, kindArg: String?, inBandMetadataTrackDispatchTypeArg: String?, readyStateArg: TextTrackReadyState, typeArg: TextTrackType, sourceArg: String?, isForcedArg: Boolean, modeArg: TextTrackMode, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onAddTextTrack", codec)
    channel.send(listOf(idArg, uidArg, labelArg, languageArg, kindArg, inBandMetadataTrackDispatchTypeArg, readyStateArg.raw, typeArg.raw, sourceArg, isForcedArg, modeArg.raw)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onRemoveTextTrack(uidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onRemoveTextTrack", codec)
    channel.send(listOf(uidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTextTrackListChange(uidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackListChange", codec)
    channel.send(listOf(uidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTextTrackAddCue(textTrackUidArg: Long, idArg: String, uidArg: Long, startTimeArg: Double, endTimeArg: Double, contentArg: String, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackAddCue", codec)
    channel.send(listOf(textTrackUidArg, idArg, uidArg, startTimeArg, endTimeArg, contentArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTextTrackRemoveCue(textTrackUidArg: Long, cueUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackRemoveCue", codec)
    channel.send(listOf(textTrackUidArg, cueUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTextTrackEnterCue(textTrackUidArg: Long, cueUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackEnterCue", codec)
    channel.send(listOf(textTrackUidArg, cueUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTextTrackExitCue(textTrackUidArg: Long, cueUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackExitCue", codec)
    channel.send(listOf(textTrackUidArg, cueUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTextTrackCueChange(textTrackUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackCueChange", codec)
    channel.send(listOf(textTrackUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTextTrackChange(textTrackUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackChange", codec)
    channel.send(listOf(textTrackUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onCueEnter(textTrackUidArg: Long, cueUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onCueEnter", codec)
    channel.send(listOf(textTrackUidArg, cueUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onCueExit(textTrackUidArg: Long, cueUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onCueExit", codec)
    channel.send(listOf(textTrackUidArg, cueUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onCueUpdate(textTrackUidArg: Long, cueUidArg: Long, endTimeArg: Double, contentArg: String, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterTextTracksAPI.onCueUpdate", codec)
    channel.send(listOf(textTrackUidArg, cueUidArg, endTimeArg, contentArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object THEOplayerNativeAPICodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DRMConfiguration.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FairPlayDRMConfiguration.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SourceDescription.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TimeRange.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TypedSource.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          WidevineDRMConfiguration.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is DRMConfiguration -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is FairPlayDRMConfiguration -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is SourceDescription -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is TimeRange -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is TypedSource -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is WidevineDRMConfiguration -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface THEOplayerNativeAPI {
  fun setSource(source: SourceDescription?)
  fun getSource(): SourceDescription?
  fun setAutoplay(autoplay: Boolean)
  fun isAutoplay(): Boolean
  fun play()
  fun pause()
  fun isPaused(): Boolean
  fun setCurrentTime(currentTime: Double)
  fun getCurrentTime(): Double
  fun setCurrentProgramDateTime(currentProgramDateTime: Long)
  fun getCurrentProgramDateTime(): Long?
  fun getDuration(): Double
  fun setPlaybackRate(playbackRate: Double)
  fun getPlaybackRate(): Double
  fun setVolume(volume: Double)
  fun getVolume(): Double
  fun setMuted(muted: Boolean)
  fun isMuted(): Boolean
  fun setPreload(preload: PreloadType)
  fun getPreload(): PreloadType
  fun getReadyState(): ReadyState
  fun isSeeking(): Boolean
  fun isEnded(): Boolean
  fun getVideoWidth(): Long
  fun getVideoHeight(): Long
  fun getBuffered(): List<TimeRange>
  fun getSeekable(): List<TimeRange>
  fun getPlayed(): List<TimeRange>
  fun getError(): String?
  fun stop()
  fun dispose()

  companion object {
    /** The codec used by THEOplayerNativeAPI. */
    val codec: MessageCodec<Any?> by lazy {
      THEOplayerNativeAPICodec
    }
    /** Sets up an instance of `THEOplayerNativeAPI` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: THEOplayerNativeAPI?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.setSource", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceArg = args[0] as SourceDescription?
            var wrapped: List<Any?>
            try {
              api.setSource(sourceArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getSource", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSource())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.setAutoplay", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val autoplayArg = args[0] as Boolean
            var wrapped: List<Any?>
            try {
              api.setAutoplay(autoplayArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.isAutoplay", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isAutoplay())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.play", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.play()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.pause", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.pause()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.isPaused", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isPaused())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.setCurrentTime", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val currentTimeArg = args[0] as Double
            var wrapped: List<Any?>
            try {
              api.setCurrentTime(currentTimeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getCurrentTime", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getCurrentTime())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.setCurrentProgramDateTime", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val currentProgramDateTimeArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.setCurrentProgramDateTime(currentProgramDateTimeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getCurrentProgramDateTime", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getCurrentProgramDateTime())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getDuration", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDuration())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.setPlaybackRate", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playbackRateArg = args[0] as Double
            var wrapped: List<Any?>
            try {
              api.setPlaybackRate(playbackRateArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getPlaybackRate", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getPlaybackRate())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.setVolume", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val volumeArg = args[0] as Double
            var wrapped: List<Any?>
            try {
              api.setVolume(volumeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getVolume", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getVolume())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.setMuted", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val mutedArg = args[0] as Boolean
            var wrapped: List<Any?>
            try {
              api.setMuted(mutedArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.isMuted", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isMuted())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.setPreload", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val preloadArg = PreloadType.ofRaw(args[0] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setPreload(preloadArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getPreload", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getPreload().raw)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getReadyState", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getReadyState().raw)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.isSeeking", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isSeeking())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.isEnded", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isEnded())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getVideoWidth", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getVideoWidth())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getVideoHeight", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getVideoHeight())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getBuffered", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getBuffered())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getSeekable", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSeekable())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getPlayed", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getPlayed())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.getError", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getError())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.stop", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.stop()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAPI.dispose", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.dispose()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object THEOplayerFlutterAPICodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DRMConfiguration.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FairPlayDRMConfiguration.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SourceDescription.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TypedSource.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          WidevineDRMConfiguration.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is DRMConfiguration -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is FairPlayDRMConfiguration -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is SourceDescription -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is TypedSource -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is WidevineDRMConfiguration -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
@Suppress("UNCHECKED_CAST")
class THEOplayerFlutterAPI(private val binaryMessenger: BinaryMessenger) {
  companion object {
    /** The codec used by THEOplayerFlutterAPI. */
    val codec: MessageCodec<Any?> by lazy {
      THEOplayerFlutterAPICodec
    }
  }
  fun onSourceChange(sourceArg: SourceDescription?, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onSourceChange", codec)
    channel.send(listOf(sourceArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onPlay(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onPlay", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onPlaying(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onPlaying", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onPause(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onPause", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onWaiting(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onWaiting", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onDurationChange(durationArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onDurationChange", codec)
    channel.send(listOf(durationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onProgress(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onProgress", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTimeUpdate(currentTimeArg: Double, currentProgramDateTimeArg: Long?, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onTimeUpdate", codec)
    channel.send(listOf(currentTimeArg, currentProgramDateTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onRateChange(currentTimeArg: Double, playbackRateArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onRateChange", codec)
    channel.send(listOf(currentTimeArg, playbackRateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onSeeking(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onSeeking", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onSeeked(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onSeeked", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onVolumeChange(currentTimeArg: Double, volumeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onVolumeChange", codec)
    channel.send(listOf(currentTimeArg, volumeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onResize(currentTimeArg: Double, widthArg: Long, heightArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onResize", codec)
    channel.send(listOf(currentTimeArg, widthArg, heightArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onEnded(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onEnded", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onError(errorArg: String, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onError", codec)
    channel.send(listOf(errorArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onDestroy(callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onDestroy", codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onReadyStateChange(currentTimeArg: Double, readyStateArg: ReadyState, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onReadyStateChange", codec)
    channel.send(listOf(currentTimeArg, readyStateArg.raw)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onLoadStart(callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onLoadStart", codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onLoadedMetadata(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onLoadedMetadata", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onLoadedData(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onLoadedData", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onCanPlay(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onCanPlay", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onCanPlayThrough(currentTimeArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAPI.onCanPlayThrough", codec)
    channel.send(listOf(currentTimeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface THEOplayerNativeVideoTracksAPI {
  fun setTargetQuality(videoTrackUid: Long, qualityUid: Long?)
  fun setTargetQualities(videoTrackUid: Long, qualitiesUid: List<Long>?)
  fun setEnabled(videoTrackUid: Long, enabled: Boolean)

  companion object {
    /** The codec used by THEOplayerNativeVideoTracksAPI. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `THEOplayerNativeVideoTracksAPI` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: THEOplayerNativeVideoTracksAPI?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeVideoTracksAPI.setTargetQuality", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val videoTrackUidArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val qualityUidArg = args[1].let { if (it is Int) it.toLong() else it as Long? }
            var wrapped: List<Any?>
            try {
              api.setTargetQuality(videoTrackUidArg, qualityUidArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeVideoTracksAPI.setTargetQualities", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val videoTrackUidArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val qualitiesUidArg = args[1] as List<Long>?
            var wrapped: List<Any?>
            try {
              api.setTargetQualities(videoTrackUidArg, qualitiesUidArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeVideoTracksAPI.setEnabled", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val videoTrackUidArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setEnabled(videoTrackUidArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
@Suppress("UNCHECKED_CAST")
class THEOplayerFlutterVideoTracksAPI(private val binaryMessenger: BinaryMessenger) {
  companion object {
    /** The codec used by THEOplayerFlutterVideoTracksAPI. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
  }
  fun onAddVideoTrack(idArg: String?, uidArg: Long, labelArg: String?, languageArg: String?, kindArg: String?, isEnabledArg: Boolean, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterVideoTracksAPI.onAddVideoTrack", codec)
    channel.send(listOf(idArg, uidArg, labelArg, languageArg, kindArg, isEnabledArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onVideoTrackAddQuality(videoTrackUidArg: Long, qualityIdArg: String, qualityUidArg: Long, nameArg: String?, bandwidthArg: Long, codecsArg: String?, widthArg: Long, heightArg: Long, frameRateArg: Double, firstFrameArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterVideoTracksAPI.onVideoTrackAddQuality", codec)
    channel.send(listOf(videoTrackUidArg, qualityIdArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, widthArg, heightArg, frameRateArg, firstFrameArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onRemoveVideoTrack(uidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterVideoTracksAPI.onRemoveVideoTrack", codec)
    channel.send(listOf(uidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onVideoTrackListChange(uidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterVideoTracksAPI.onVideoTrackListChange", codec)
    channel.send(listOf(uidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTargetQualityChange(videoTrackUidArg: Long, qualitiesUidArg: List<Long>, qualityUidArg: Long?, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterVideoTracksAPI.onTargetQualityChange", codec)
    channel.send(listOf(videoTrackUidArg, qualitiesUidArg, qualityUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onActiveQualityChange(videoTrackUidArg: Long, qualityUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterVideoTracksAPI.onActiveQualityChange", codec)
    channel.send(listOf(videoTrackUidArg, qualityUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onQualityUpdate(videoTrackUidArg: Long, qualityUidArg: Long, nameArg: String?, bandwidthArg: Long, codecsArg: String?, widthArg: Long, heightArg: Long, frameRateArg: Double, firstFrameArg: Double, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterVideoTracksAPI.onQualityUpdate", codec)
    channel.send(listOf(videoTrackUidArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, widthArg, heightArg, frameRateArg, firstFrameArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface THEOplayerNativeAudioTracksAPI {
  fun setTargetQuality(audioTrackUid: Long, qualityUid: Long?)
  fun setTargetQualities(audioTrackUid: Long, qualitiesUid: List<Long>?)
  fun setEnabled(audioTrackUid: Long, enabled: Boolean)

  companion object {
    /** The codec used by THEOplayerNativeAudioTracksAPI. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `THEOplayerNativeAudioTracksAPI` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: THEOplayerNativeAudioTracksAPI?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAudioTracksAPI.setTargetQuality", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val audioTrackUidArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val qualityUidArg = args[1].let { if (it is Int) it.toLong() else it as Long? }
            var wrapped: List<Any?>
            try {
              api.setTargetQuality(audioTrackUidArg, qualityUidArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAudioTracksAPI.setTargetQualities", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val audioTrackUidArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val qualitiesUidArg = args[1] as List<Long>?
            var wrapped: List<Any?>
            try {
              api.setTargetQualities(audioTrackUidArg, qualitiesUidArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerNativeAudioTracksAPI.setEnabled", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val audioTrackUidArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            val enabledArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setEnabled(audioTrackUidArg, enabledArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
@Suppress("UNCHECKED_CAST")
class THEOplayerFlutterAudioTracksAPI(private val binaryMessenger: BinaryMessenger) {
  companion object {
    /** The codec used by THEOplayerFlutterAudioTracksAPI. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
  }
  fun onAddAudioTrack(idArg: String?, uidArg: Long, labelArg: String?, languageArg: String?, kindArg: String?, isEnabledArg: Boolean, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAudioTracksAPI.onAddAudioTrack", codec)
    channel.send(listOf(idArg, uidArg, labelArg, languageArg, kindArg, isEnabledArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onAudioTrackAddQuality(audioTrackUidArg: Long, qualityIdArg: String, qualityUidArg: Long, nameArg: String?, bandwidthArg: Long, codecsArg: String?, audioSamplingRateArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAudioTracksAPI.onAudioTrackAddQuality", codec)
    channel.send(listOf(audioTrackUidArg, qualityIdArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, audioSamplingRateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onRemoveAudioTrack(uidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAudioTracksAPI.onRemoveAudioTrack", codec)
    channel.send(listOf(uidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onAudioTrackListChange(uidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAudioTracksAPI.onAudioTrackListChange", codec)
    channel.send(listOf(uidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onTargetQualityChange(audioTrackUidArg: Long, qualitiesUidArg: List<Long>, qualityUidArg: Long?, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAudioTracksAPI.onTargetQualityChange", codec)
    channel.send(listOf(audioTrackUidArg, qualitiesUidArg, qualityUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onActiveQualityChange(audioTrackUidArg: Long, qualityUidArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAudioTracksAPI.onActiveQualityChange", codec)
    channel.send(listOf(audioTrackUidArg, qualityUidArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
  fun onQualityUpdate(audioTrackUidArg: Long, qualityUidArg: Long, nameArg: String?, bandwidthArg: Long, codecsArg: String?, audioSamplingRateArg: Long, callback: (Result<Unit>) -> Unit) {
    val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_theoplayer_sdk_platform_interface.THEOplayerFlutterAudioTracksAPI.onQualityUpdate", codec)
    channel.send(listOf(audioTrackUidArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, audioSamplingRateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)));
        } else {
          callback(Result.success(Unit));
        }
      } else {
        callback(Result.failure(FlutterError("channel-error",  "Unable to establish connection on channel.", "")));
      } 
    }
  }
}
