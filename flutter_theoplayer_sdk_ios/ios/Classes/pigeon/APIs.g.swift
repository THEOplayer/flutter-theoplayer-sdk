// Autogenerated from Pigeon (v12.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum ReadyState: Int {
  case haveNothing = 0
  case haveMetadata = 1
  case haveCurrentData = 2
  case haveFutureData = 3
  case haveEnoughData = 4
}

enum TextTrackMode: Int {
  case disabled = 0
  case hidden = 1
  case showing = 2
}

enum TextTrackType: Int {
  case none = 0
  case srt = 1
  case ttml = 2
  case webvtt = 3
  case emsg = 4
  case eventstream = 5
  case id3 = 6
  case cea608 = 7
  case daterange = 8
}

enum TextTrackReadyState: Int {
  case none = 0
  case loading = 1
  case loaded = 2
  case error = 3
}

enum PreloadType: Int {
  case none = 0
  case auto = 1
  case metadata = 2
}

/// Generated class from Pigeon that represents data sent in messages.
struct TimeRange {
  var start: Double
  var end: Double

  static func fromList(_ list: [Any?]) -> TimeRange? {
    let start = list[0] as! Double
    let end = list[1] as! Double

    return TimeRange(
      start: start,
      end: end
    )
  }
  func toList() -> [Any?] {
    return [
      start,
      end,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SourceDescription {
  var sources: [TypedSource?]

  static func fromList(_ list: [Any?]) -> SourceDescription? {
    let sources = list[0] as! [TypedSource?]

    return SourceDescription(
      sources: sources
    )
  }
  func toList() -> [Any?] {
    return [
      sources,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct TypedSource {
  var src: String
  var drm: DRMConfiguration? = nil

  static func fromList(_ list: [Any?]) -> TypedSource? {
    let src = list[0] as! String
    var drm: DRMConfiguration? = nil
    if let drmList: [Any?] = nilOrValue(list[1]) {
      drm = DRMConfiguration.fromList(drmList)
    }

    return TypedSource(
      src: src,
      drm: drm
    )
  }
  func toList() -> [Any?] {
    return [
      src,
      drm?.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DRMConfiguration {
  var widevine: WidevineDRMConfiguration? = nil
  var fairplay: FairPlayDRMConfiguration? = nil
  var customIntegrationId: String? = nil
  var integrationParameters: [String?: String?]? = nil

  static func fromList(_ list: [Any?]) -> DRMConfiguration? {
    var widevine: WidevineDRMConfiguration? = nil
    if let widevineList: [Any?] = nilOrValue(list[0]) {
      widevine = WidevineDRMConfiguration.fromList(widevineList)
    }
    var fairplay: FairPlayDRMConfiguration? = nil
    if let fairplayList: [Any?] = nilOrValue(list[1]) {
      fairplay = FairPlayDRMConfiguration.fromList(fairplayList)
    }
    let customIntegrationId: String? = nilOrValue(list[2])
    let integrationParameters: [String?: String?]? = nilOrValue(list[3])

    return DRMConfiguration(
      widevine: widevine,
      fairplay: fairplay,
      customIntegrationId: customIntegrationId,
      integrationParameters: integrationParameters
    )
  }
  func toList() -> [Any?] {
    return [
      widevine?.toList(),
      fairplay?.toList(),
      customIntegrationId,
      integrationParameters,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct WidevineDRMConfiguration {
  var licenseAcquisitionURL: String
  var headers: [String?: String?]? = nil

  static func fromList(_ list: [Any?]) -> WidevineDRMConfiguration? {
    let licenseAcquisitionURL = list[0] as! String
    let headers: [String?: String?]? = nilOrValue(list[1])

    return WidevineDRMConfiguration(
      licenseAcquisitionURL: licenseAcquisitionURL,
      headers: headers
    )
  }
  func toList() -> [Any?] {
    return [
      licenseAcquisitionURL,
      headers,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct FairPlayDRMConfiguration {
  var licenseAcquisitionURL: String
  var certificateURL: String
  var headers: [String?: String?]? = nil

  static func fromList(_ list: [Any?]) -> FairPlayDRMConfiguration? {
    let licenseAcquisitionURL = list[0] as! String
    let certificateURL = list[1] as! String
    let headers: [String?: String?]? = nilOrValue(list[2])

    return FairPlayDRMConfiguration(
      licenseAcquisitionURL: licenseAcquisitionURL,
      certificateURL: certificateURL,
      headers: headers
    )
  }
  func toList() -> [Any?] {
    return [
      licenseAcquisitionURL,
      certificateURL,
      headers,
    ]
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeTextTracksAPI {
  func setMode(textTrackUid: Int64, mode: TextTrackMode) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeTextTracksAPISetup {
  /// The codec used by THEOplayerNativeTextTracksAPI.
  /// Sets up an instance of `THEOplayerNativeTextTracksAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeTextTracksAPI?) {
    let setModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeTextTracksAPI.setMode", binaryMessenger: binaryMessenger)
    if let api = api {
      setModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let textTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let modeArg = TextTrackMode(rawValue: args[1] as! Int)!
        do {
          try api.setMode(textTrackUid: textTrackUidArg, mode: modeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setModeChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterTextTracksAPIProtocol {
  func onAddTextTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, inBandMetadataTrackDispatchType inBandMetadataTrackDispatchTypeArg: String?, readyState readyStateArg: TextTrackReadyState, type typeArg: TextTrackType, source sourceArg: String?, isForced isForcedArg: Bool, mode modeArg: TextTrackMode, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRemoveTextTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackAddCue(textTrackUid textTrackUidArg: Int64, id idArg: String, uid uidArg: Int64, startTime startTimeArg: Double, endTime endTimeArg: Double, content contentArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackRemoveCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackEnterCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackExitCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackCueChange(textTrackUid textTrackUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTextTrackChange(textTrackUid textTrackUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCueEnter(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCueExit(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCueUpdate(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, endTime endTimeArg: Double, content contentArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterTextTracksAPI: THEOplayerFlutterTextTracksAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  func onAddTextTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, inBandMetadataTrackDispatchType inBandMetadataTrackDispatchTypeArg: String?, readyState readyStateArg: TextTrackReadyState, type typeArg: TextTrackType, source sourceArg: String?, isForced isForcedArg: Bool, mode modeArg: TextTrackMode, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onAddTextTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([idArg, uidArg, labelArg, languageArg, kindArg, inBandMetadataTrackDispatchTypeArg, readyStateArg.rawValue, typeArg.rawValue, sourceArg, isForcedArg, modeArg.rawValue] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRemoveTextTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onRemoveTextTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackListChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackAddCue(textTrackUid textTrackUidArg: Int64, id idArg: String, uid uidArg: Int64, startTime startTimeArg: Double, endTime endTimeArg: Double, content contentArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackAddCue", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, idArg, uidArg, startTimeArg, endTimeArg, contentArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackRemoveCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackRemoveCue", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackEnterCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackEnterCue", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackExitCue(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackExitCue", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackCueChange(textTrackUid textTrackUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackCueChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTextTrackChange(textTrackUid textTrackUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onTextTrackChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCueEnter(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onCueEnter", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCueExit(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onCueExit", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCueUpdate(textTrackUid textTrackUidArg: Int64, cueUid cueUidArg: Int64, endTime endTimeArg: Double, content contentArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterTextTracksAPI.onCueUpdate", binaryMessenger: binaryMessenger)
    channel.sendMessage([textTrackUidArg, cueUidArg, endTimeArg, contentArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
private class THEOplayerNativeAPICodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return DRMConfiguration.fromList(self.readValue() as! [Any?])
      case 129:
        return FairPlayDRMConfiguration.fromList(self.readValue() as! [Any?])
      case 130:
        return SourceDescription.fromList(self.readValue() as! [Any?])
      case 131:
        return TimeRange.fromList(self.readValue() as! [Any?])
      case 132:
        return TypedSource.fromList(self.readValue() as! [Any?])
      case 133:
        return WidevineDRMConfiguration.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class THEOplayerNativeAPICodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? DRMConfiguration {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? FairPlayDRMConfiguration {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? SourceDescription {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? TimeRange {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? TypedSource {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? WidevineDRMConfiguration {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class THEOplayerNativeAPICodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return THEOplayerNativeAPICodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return THEOplayerNativeAPICodecWriter(data: data)
  }
}

class THEOplayerNativeAPICodec: FlutterStandardMessageCodec {
  static let shared = THEOplayerNativeAPICodec(readerWriter: THEOplayerNativeAPICodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeAPI {
  func setSource(source: SourceDescription?) throws
  func getSource() throws -> SourceDescription?
  func setAutoplay(autoplay: Bool) throws
  func isAutoplay() throws -> Bool
  func play() throws
  func pause() throws
  func isPaused() throws -> Bool
  func setCurrentTime(currentTime: Double) throws
  func getCurrentTime() throws -> Double
  func setCurrentProgramDateTime(currentProgramDateTime: Int64) throws
  func getCurrentProgramDateTime() throws -> Int64?
  func getDuration() throws -> Double
  func setPlaybackRate(playbackRate: Double) throws
  func getPlaybackRate() throws -> Double
  func setVolume(volume: Double) throws
  func getVolume() throws -> Double
  func setMuted(muted: Bool) throws
  func isMuted() throws -> Bool
  func setPreload(preload: PreloadType) throws
  func getPreload() throws -> PreloadType
  func getReadyState() throws -> ReadyState
  func isSeeking() throws -> Bool
  func isEnded() throws -> Bool
  func getVideoWidth() throws -> Int64
  func getVideoHeight() throws -> Int64
  func getBuffered() throws -> [TimeRange]
  func getSeekable() throws -> [TimeRange]
  func getPlayed() throws -> [TimeRange]
  func getError() throws -> String?
  func stop() throws
  func dispose() throws
  func startChromecast() throws
  func stopChromecast() throws
  func setChromecastStartingSource(source: SourceDescription?) throws
  func setChromecastStoppingSource(source: SourceDescription?) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeAPISetup {
  /// The codec used by THEOplayerNativeAPI.
  static var codec: FlutterStandardMessageCodec { THEOplayerNativeAPICodec.shared }
  /// Sets up an instance of `THEOplayerNativeAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeAPI?) {
    let setSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setSource", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSourceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceArg: SourceDescription? = nilOrValue(args[0])
        do {
          try api.setSource(source: sourceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setSourceChannel.setMessageHandler(nil)
    }
    let getSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getSource", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSourceChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSource()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSourceChannel.setMessageHandler(nil)
    }
    let setAutoplayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setAutoplay", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAutoplayChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let autoplayArg = args[0] as! Bool
        do {
          try api.setAutoplay(autoplay: autoplayArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAutoplayChannel.setMessageHandler(nil)
    }
    let isAutoplayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isAutoplay", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isAutoplayChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isAutoplay()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isAutoplayChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { _, reply in
        do {
          try api.play()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { _, reply in
        do {
          try api.pause()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let isPausedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isPaused", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPausedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isPaused()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPausedChannel.setMessageHandler(nil)
    }
    let setCurrentTimeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setCurrentTime", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCurrentTimeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let currentTimeArg = args[0] as! Double
        do {
          try api.setCurrentTime(currentTime: currentTimeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCurrentTimeChannel.setMessageHandler(nil)
    }
    let getCurrentTimeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getCurrentTime", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentTimeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCurrentTime()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentTimeChannel.setMessageHandler(nil)
    }
    let setCurrentProgramDateTimeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setCurrentProgramDateTime", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCurrentProgramDateTimeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let currentProgramDateTimeArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.setCurrentProgramDateTime(currentProgramDateTime: currentProgramDateTimeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCurrentProgramDateTimeChannel.setMessageHandler(nil)
    }
    let getCurrentProgramDateTimeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getCurrentProgramDateTime", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentProgramDateTimeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCurrentProgramDateTime()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentProgramDateTimeChannel.setMessageHandler(nil)
    }
    let getDurationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getDuration", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDurationChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getDuration()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDurationChannel.setMessageHandler(nil)
    }
    let setPlaybackRateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setPlaybackRate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPlaybackRateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playbackRateArg = args[0] as! Double
        do {
          try api.setPlaybackRate(playbackRate: playbackRateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPlaybackRateChannel.setMessageHandler(nil)
    }
    let getPlaybackRateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getPlaybackRate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlaybackRateChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPlaybackRate()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPlaybackRateChannel.setMessageHandler(nil)
    }
    let setVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setVolume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let volumeArg = args[0] as! Double
        do {
          try api.setVolume(volume: volumeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVolumeChannel.setMessageHandler(nil)
    }
    let getVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getVolume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVolumeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getVolume()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVolumeChannel.setMessageHandler(nil)
    }
    let setMutedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setMuted", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMutedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let mutedArg = args[0] as! Bool
        do {
          try api.setMuted(muted: mutedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMutedChannel.setMessageHandler(nil)
    }
    let isMutedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isMuted", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isMutedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isMuted()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isMutedChannel.setMessageHandler(nil)
    }
    let setPreloadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setPreload", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPreloadChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let preloadArg = PreloadType(rawValue: args[0] as! Int)!
        do {
          try api.setPreload(preload: preloadArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPreloadChannel.setMessageHandler(nil)
    }
    let getPreloadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getPreload", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPreloadChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPreload()
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPreloadChannel.setMessageHandler(nil)
    }
    let getReadyStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getReadyState", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getReadyStateChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getReadyState()
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getReadyStateChannel.setMessageHandler(nil)
    }
    let isSeekingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isSeeking", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isSeekingChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isSeeking()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isSeekingChannel.setMessageHandler(nil)
    }
    let isEndedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.isEnded", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isEndedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isEnded()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isEndedChannel.setMessageHandler(nil)
    }
    let getVideoWidthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getVideoWidth", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoWidthChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getVideoWidth()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoWidthChannel.setMessageHandler(nil)
    }
    let getVideoHeightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getVideoHeight", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoHeightChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getVideoHeight()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoHeightChannel.setMessageHandler(nil)
    }
    let getBufferedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getBuffered", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getBufferedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getBuffered()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getBufferedChannel.setMessageHandler(nil)
    }
    let getSeekableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getSeekable", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSeekableChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSeekable()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSeekableChannel.setMessageHandler(nil)
    }
    let getPlayedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getPlayed", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlayedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPlayed()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPlayedChannel.setMessageHandler(nil)
    }
    let getErrorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.getError", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getErrorChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getError()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getErrorChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.stop", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { _, reply in
        do {
          try api.stop()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.dispose", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { _, reply in
        do {
          try api.dispose()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    let startChromecastChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.startChromecast", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startChromecastChannel.setMessageHandler { _, reply in
        do {
          try api.startChromecast()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startChromecastChannel.setMessageHandler(nil)
    }
    let stopChromecastChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.stopChromecast", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChromecastChannel.setMessageHandler { _, reply in
        do {
          try api.stopChromecast()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChromecastChannel.setMessageHandler(nil)
    }
    let setChromecastStartingSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setChromecastStartingSource", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setChromecastStartingSourceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceArg: SourceDescription? = nilOrValue(args[0])
        do {
          try api.setChromecastStartingSource(source: sourceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setChromecastStartingSourceChannel.setMessageHandler(nil)
    }
    let setChromecastStoppingSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAPI.setChromecastStoppingSource", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setChromecastStoppingSourceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceArg: SourceDescription? = nilOrValue(args[0])
        do {
          try api.setChromecastStoppingSource(source: sourceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setChromecastStoppingSourceChannel.setMessageHandler(nil)
    }
  }
}
private class THEOplayerFlutterAPICodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return DRMConfiguration.fromList(self.readValue() as! [Any?])
      case 129:
        return FairPlayDRMConfiguration.fromList(self.readValue() as! [Any?])
      case 130:
        return SourceDescription.fromList(self.readValue() as! [Any?])
      case 131:
        return TypedSource.fromList(self.readValue() as! [Any?])
      case 132:
        return WidevineDRMConfiguration.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class THEOplayerFlutterAPICodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? DRMConfiguration {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? FairPlayDRMConfiguration {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? SourceDescription {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? TypedSource {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? WidevineDRMConfiguration {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class THEOplayerFlutterAPICodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return THEOplayerFlutterAPICodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return THEOplayerFlutterAPICodecWriter(data: data)
  }
}

class THEOplayerFlutterAPICodec: FlutterStandardMessageCodec {
  static let shared = THEOplayerFlutterAPICodec(readerWriter: THEOplayerFlutterAPICodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterAPIProtocol {
  func onSourceChange(source sourceArg: SourceDescription?, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onPlay(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onPlaying(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onPause(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onWaiting(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onDurationChange(duration durationArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onProgress(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTimeUpdate(currentTime currentTimeArg: Double, currentProgramDateTime currentProgramDateTimeArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRateChange(currentTime currentTimeArg: Double, playbackRate playbackRateArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onSeeking(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onSeeked(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onVolumeChange(currentTime currentTimeArg: Double, volume volumeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onResize(currentTime currentTimeArg: Double, width widthArg: Int64, height heightArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onEnded(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onError(error errorArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onDestroy(completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onReadyStateChange(currentTime currentTimeArg: Double, readyState readyStateArg: ReadyState, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onLoadStart(completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onLoadedMetadata(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onLoadedData(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCanPlay(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onCanPlayThrough(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterAPI: THEOplayerFlutterAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return THEOplayerFlutterAPICodec.shared
  }
  func onSourceChange(source sourceArg: SourceDescription?, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onSourceChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([sourceArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onPlay(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onPlay", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onPlaying(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onPlaying", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onPause(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onPause", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onWaiting(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onWaiting", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onDurationChange(duration durationArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onDurationChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([durationArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onProgress(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onProgress", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTimeUpdate(currentTime currentTimeArg: Double, currentProgramDateTime currentProgramDateTimeArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onTimeUpdate", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, currentProgramDateTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRateChange(currentTime currentTimeArg: Double, playbackRate playbackRateArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onRateChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, playbackRateArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onSeeking(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onSeeking", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onSeeked(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onSeeked", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onVolumeChange(currentTime currentTimeArg: Double, volume volumeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onVolumeChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, volumeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onResize(currentTime currentTimeArg: Double, width widthArg: Int64, height heightArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onResize", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, widthArg, heightArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onEnded(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onEnded", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onError(error errorArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onError", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([errorArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onDestroy(completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onDestroy", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { _ in
      completion(.success(Void()))
    }
  }
  func onReadyStateChange(currentTime currentTimeArg: Double, readyState readyStateArg: ReadyState, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onReadyStateChange", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg, readyStateArg.rawValue] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onLoadStart(completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onLoadStart", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage(nil) { _ in
      completion(.success(Void()))
    }
  }
  func onLoadedMetadata(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onLoadedMetadata", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onLoadedData(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onLoadedData", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCanPlay(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onCanPlay", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onCanPlayThrough(currentTime currentTimeArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAPI.onCanPlayThrough", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([currentTimeArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeVideoTracksAPI {
  func setTargetQuality(videoTrackUid: Int64, qualityUid: Int64?) throws
  func setTargetQualities(videoTrackUid: Int64, qualitiesUid: [Int64]?) throws
  func setEnabled(videoTrackUid: Int64, enabled: Bool) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeVideoTracksAPISetup {
  /// The codec used by THEOplayerNativeVideoTracksAPI.
  /// Sets up an instance of `THEOplayerNativeVideoTracksAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeVideoTracksAPI?) {
    let setTargetQualityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeVideoTracksAPI.setTargetQuality", binaryMessenger: binaryMessenger)
    if let api = api {
      setTargetQualityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let videoTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let qualityUidArg: Int64? = isNullish(args[1]) ? nil : (args[1] is Int64? ? args[1] as! Int64? : Int64(args[1] as! Int32))
        do {
          try api.setTargetQuality(videoTrackUid: videoTrackUidArg, qualityUid: qualityUidArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTargetQualityChannel.setMessageHandler(nil)
    }
    let setTargetQualitiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeVideoTracksAPI.setTargetQualities", binaryMessenger: binaryMessenger)
    if let api = api {
      setTargetQualitiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let videoTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let qualitiesUidArg: [Int64]? = nilOrValue(args[1])
        do {
          try api.setTargetQualities(videoTrackUid: videoTrackUidArg, qualitiesUid: qualitiesUidArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTargetQualitiesChannel.setMessageHandler(nil)
    }
    let setEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeVideoTracksAPI.setEnabled", binaryMessenger: binaryMessenger)
    if let api = api {
      setEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let videoTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setEnabled(videoTrackUid: videoTrackUidArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setEnabledChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterVideoTracksAPIProtocol {
  func onAddVideoTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, isEnabled isEnabledArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onVideoTrackAddQuality(videoTrackUid videoTrackUidArg: Int64, qualityId qualityIdArg: String, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, width widthArg: Int64, height heightArg: Int64, frameRate frameRateArg: Double, firstFrame firstFrameArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRemoveVideoTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onVideoTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTargetQualityChange(videoTrackUid videoTrackUidArg: Int64, qualitiesUid qualitiesUidArg: [Int64], qualityUid qualityUidArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onActiveQualityChange(videoTrackUid videoTrackUidArg: Int64, qualityUid qualityUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onQualityUpdate(videoTrackUid videoTrackUidArg: Int64, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, width widthArg: Int64, height heightArg: Int64, frameRate frameRateArg: Double, firstFrame firstFrameArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterVideoTracksAPI: THEOplayerFlutterVideoTracksAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  func onAddVideoTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, isEnabled isEnabledArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onAddVideoTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([idArg, uidArg, labelArg, languageArg, kindArg, isEnabledArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onVideoTrackAddQuality(videoTrackUid videoTrackUidArg: Int64, qualityId qualityIdArg: String, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, width widthArg: Int64, height heightArg: Int64, frameRate frameRateArg: Double, firstFrame firstFrameArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onVideoTrackAddQuality", binaryMessenger: binaryMessenger)
    channel.sendMessage([videoTrackUidArg, qualityIdArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, widthArg, heightArg, frameRateArg, firstFrameArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRemoveVideoTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onRemoveVideoTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onVideoTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onVideoTrackListChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTargetQualityChange(videoTrackUid videoTrackUidArg: Int64, qualitiesUid qualitiesUidArg: [Int64], qualityUid qualityUidArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onTargetQualityChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([videoTrackUidArg, qualitiesUidArg, qualityUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onActiveQualityChange(videoTrackUid videoTrackUidArg: Int64, qualityUid qualityUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onActiveQualityChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([videoTrackUidArg, qualityUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onQualityUpdate(videoTrackUid videoTrackUidArg: Int64, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, width widthArg: Int64, height heightArg: Int64, frameRate frameRateArg: Double, firstFrame firstFrameArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterVideoTracksAPI.onQualityUpdate", binaryMessenger: binaryMessenger)
    channel.sendMessage([videoTrackUidArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, widthArg, heightArg, frameRateArg, firstFrameArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol THEOplayerNativeAudioTracksAPI {
  func setTargetQuality(audioTrackUid: Int64, qualityUid: Int64?) throws
  func setTargetQualities(audioTrackUid: Int64, qualitiesUid: [Int64]?) throws
  func setEnabled(audioTrackUid: Int64, enabled: Bool) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class THEOplayerNativeAudioTracksAPISetup {
  /// The codec used by THEOplayerNativeAudioTracksAPI.
  /// Sets up an instance of `THEOplayerNativeAudioTracksAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: THEOplayerNativeAudioTracksAPI?) {
    let setTargetQualityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAudioTracksAPI.setTargetQuality", binaryMessenger: binaryMessenger)
    if let api = api {
      setTargetQualityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let audioTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let qualityUidArg: Int64? = isNullish(args[1]) ? nil : (args[1] is Int64? ? args[1] as! Int64? : Int64(args[1] as! Int32))
        do {
          try api.setTargetQuality(audioTrackUid: audioTrackUidArg, qualityUid: qualityUidArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTargetQualityChannel.setMessageHandler(nil)
    }
    let setTargetQualitiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAudioTracksAPI.setTargetQualities", binaryMessenger: binaryMessenger)
    if let api = api {
      setTargetQualitiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let audioTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let qualitiesUidArg: [Int64]? = nilOrValue(args[1])
        do {
          try api.setTargetQualities(audioTrackUid: audioTrackUidArg, qualitiesUid: qualitiesUidArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTargetQualitiesChannel.setMessageHandler(nil)
    }
    let setEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerNativeAudioTracksAPI.setEnabled", binaryMessenger: binaryMessenger)
    if let api = api {
      setEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let audioTrackUidArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let enabledArg = args[1] as! Bool
        do {
          try api.setEnabled(audioTrackUid: audioTrackUidArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setEnabledChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol THEOplayerFlutterAudioTracksAPIProtocol {
  func onAddAudioTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, isEnabled isEnabledArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAudioTrackAddQuality(audioTrackUid audioTrackUidArg: Int64, qualityId qualityIdArg: String, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, audioSamplingRate audioSamplingRateArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onRemoveAudioTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onAudioTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onTargetQualityChange(audioTrackUid audioTrackUidArg: Int64, qualitiesUid qualitiesUidArg: [Int64], qualityUid qualityUidArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onActiveQualityChange(audioTrackUid audioTrackUidArg: Int64, qualityUid qualityUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
  func onQualityUpdate(audioTrackUid audioTrackUidArg: Int64, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, audioSamplingRate audioSamplingRateArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class THEOplayerFlutterAudioTracksAPI: THEOplayerFlutterAudioTracksAPIProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  func onAddAudioTrack(id idArg: String?, uid uidArg: Int64, label labelArg: String?, language languageArg: String?, kind kindArg: String?, isEnabled isEnabledArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onAddAudioTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([idArg, uidArg, labelArg, languageArg, kindArg, isEnabledArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAudioTrackAddQuality(audioTrackUid audioTrackUidArg: Int64, qualityId qualityIdArg: String, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, audioSamplingRate audioSamplingRateArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onAudioTrackAddQuality", binaryMessenger: binaryMessenger)
    channel.sendMessage([audioTrackUidArg, qualityIdArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, audioSamplingRateArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onRemoveAudioTrack(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onRemoveAudioTrack", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onAudioTrackListChange(uid uidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onAudioTrackListChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([uidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onTargetQualityChange(audioTrackUid audioTrackUidArg: Int64, qualitiesUid qualitiesUidArg: [Int64], qualityUid qualityUidArg: Int64?, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onTargetQualityChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([audioTrackUidArg, qualitiesUidArg, qualityUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onActiveQualityChange(audioTrackUid audioTrackUidArg: Int64, qualityUid qualityUidArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onActiveQualityChange", binaryMessenger: binaryMessenger)
    channel.sendMessage([audioTrackUidArg, qualityUidArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
  func onQualityUpdate(audioTrackUid audioTrackUidArg: Int64, qualityUid qualityUidArg: Int64, name nameArg: String?, bandwidth bandwidthArg: Int64, codecs codecsArg: String?, audioSamplingRate audioSamplingRateArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.theoplayer_platform_interface.THEOplayerFlutterAudioTracksAPI.onQualityUpdate", binaryMessenger: binaryMessenger)
    channel.sendMessage([audioTrackUidArg, qualityUidArg, nameArg, bandwidthArg, codecsArg, audioSamplingRateArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
